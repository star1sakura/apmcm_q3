下面我直接用「接近真实 Python」的写法，把刚才那套模型方案拆成**代码级伪代码框架**。你可以直接在此基础上填充真实计算与求解细节。

> 注：此框架针对 APMCM C 题问题三（半导体+关税+出口管制+国家安全）

---

## 1. 项目结构示意（伪）

```text
project_root/
│
├─ config.py              # 全局参数、情景设置
├─ data_loader.py         # 数据读取与预处理
├─ classification.py      # 高/中/低端芯片划分
├─ calibration.py         # 参数标定
├─ policy.py              # 关税/补贴/出口管制情景
├─ model_static.py        # 单期部分均衡模型（价格-产量-贸易）
├─ model_dynamic.py       # R&D-技术演化、国家安全指数
├─ simulate.py            # 时间序列仿真主控
└─ analysis_plots.py      # 结果可视化与分析
```

下面逐个文件给出**Python 伪代码**。

---

## 2. `config.py`

```python
# config.py
import numpy as np

# 区域与芯片类型
REGIONS = ["US", "CN", "ROW"]          # 美国、中国、其他
CHIP_TYPES = ["H", "M", "L"]           # High / Mid / Low end

# 年份区间
BASE_YEAR = 2023
HIST_YEARS = list(range(2020, BASE_YEAR + 1))
SIM_YEARS = list(range(2024, 2030))    # 可根据需要修改

# 贴现因子
DISCOUNT = 0.96

# Armington 替代弹性、需求弹性等（可在 calibration 中覆盖）
DEFAULT_SIGMA = {"H": 5.0, "M": 4.0, "L": 3.0}          # 原产地替代弹性
DEFAULT_EPSILON = {
    "US": {"H": 1.5, "M": 1.2, "L": 1.0},
    "CN": {"H": 1.5, "M": 1.3, "L": 1.1},
    "ROW": {"H": 1.4, "M": 1.2, "L": 1.0}
}
DEFAULT_SUPPLY_ELASTICITY = {
    "US": {"H": 1.0, "M": 1.0, "L": 1.0},
    "CN": {"H": 1.2, "M": 1.2, "L": 1.2},
    "ROW": {"H": 1.0, "M": 1.0, "L": 1.0},
}

# R&D 强度与技术演化参数（初值，可在标定中调整）
DEFAULT_RD_INTENSITY = {
    "US": {"H": 0.20, "M": 0.18, "L": 0.12},
    "CN": {"H": 0.15, "M": 0.10, "L": 0.08},
    "ROW": {"H": 0.16, "M": 0.12, "L": 0.10},
}

TECH_PROGRESS_COEF = {"H": 0.10, "M": 0.06, "L": 0.04}

# 国家安全权重
SECURITY_WEIGHTS = {"H": 0.5, "M": 0.3, "L": 0.2}
TECH_GAP_WEIGHT = 0.5           # μ
SECURITY_VS_WELFARE = 0.3       # λ

# 其他常数
VERY_LARGE_TARIFF = 999.0       # 近似“禁运”用
```

---

## 3. `data_loader.py`：数据读取&整理

```python
# data_loader.py
import pandas as pd
from pathlib import Path

DATA_DIR = Path("/mnt/data")  # 按实际路径调整

def load_tariff_panels():
    """读取关税相关面板数据."""
    tariff_hs4 = pd.read_csv(DATA_DIR / "tariff_hs4_panel.csv")
    tariff_hs2 = pd.read_csv(DATA_DIR / "tariff_hs2_panel.csv")
    duty_by_sector = pd.read_csv(DATA_DIR / "duty_by_sector_year.csv")
    duty_total = pd.read_csv(DATA_DIR / "duty_total_year.csv")
    return {
        "tariff_hs4": tariff_hs4,
        "tariff_hs2": tariff_hs2,
        "duty_by_sector": duty_by_sector,
        "duty_total": duty_total,
    }

def load_trade_panels():
    """读取贸易额与关税收入等面板数据."""
    trade_export = pd.read_csv(DATA_DIR / "trade_export_panel.csv")
    trade_duty = pd.read_csv(DATA_DIR / "trade_duty_panel.csv")
    exports_CN_sector = pd.read_csv(DATA_DIR / "exports_CN_sector.csv")
    # 更细粒度 HS8/HS10 的 DataWeb 结果
    dataweb1 = pd.read_excel(DATA_DIR / "DataWeb-Query-Export.xlsx")
    dataweb2 = pd.read_excel(DATA_DIR / "DataWeb-Query-Export (1).xlsx")
    return {
        "trade_export": trade_export,
        "trade_duty": trade_duty,
        "exports_CN_sector": exports_CN_sector,
        "dataweb1": dataweb1,
        "dataweb2": dataweb2,
    }

def load_industry_indices():
    """读取美国半导体产出指数等."""
    ipg = pd.read_csv(DATA_DIR / "IPG3344S.csv")
    return {"ipg": ipg}

def preprocess_all():
    """做一些统一预处理，比如时间索引、单位转换、对中国/其他分组聚合等."""
    tariff_data = load_tariff_panels()
    trade_data = load_trade_panels()
    industry_data = load_industry_indices()

    # TODO: 对 trade_export 按 hs2/sector_big / partner_name 聚合
    # TODO: 对 ipg 取年度平均，构造 Y_US_semi_index[year]

    return {
        "tariff": tariff_data,
        "trade": trade_data,
        "industry": industry_data,
    }
```

---

## 4. `classification.py`：高/中/低端映射

```python
# classification.py
import pandas as pd
from typing import Dict

from config import CHIP_TYPES

def estimate_chip_type_shares_from_dataweb(dataweb1, dataweb2) -> Dict[str, float]:
    """
    利用 DataWeb 的 8542, 854231, 854232 等数据估算高/中/低端份额.
    返回如 {"H": 0.2, "M": 0.4, "L": 0.4}
    """
    # TODO: 实际代码中：
    #  1) 过滤 HS 8542 及子目
    #  2) 认为 854231 ≈ 高端逻辑，高端权重 α_H
    #  3) 854232 记为存储，根据假设拆分高端 HBM/DRAM vs 其他
    #  4) 剩余 854239 为中低端，按假设拆分
    alpha = {"H": 0.2, "M": 0.4, "L": 0.4}  # 占位
    return alpha

def split_trade_by_chip_type(trade_panel: pd.DataFrame,
                             alpha: Dict[str, float]) -> pd.DataFrame:
    """
    根据 α_H, α_M, α_L 把 HS2=85 或 HS4=8542 相关贸易额拆成 H/M/L 三部分.
    返回的 DataFrame 有字段: year, reporter, partner, chip_type, export_value, import_value
    """
    # TODO: 实现映射和拆分
    return pd.DataFrame()

def construct_region_level_series(trade_chip: pd.DataFrame) -> Dict:
    """
    把拆分后的芯片贸易流聚合到 US-CN-ROW 三个区域组合上:
      US→CN, US→ROW, CN→US, CN→ROW, ROW→US 等.
    返回一个用于标定 Armington 权重 β 的数据结构.
    """
    # TODO: groupby 计算各来源份额
    return {}
```

---

## 5. `calibration.py`：参数标定

```python
# calibration.py
from typing import Dict, Any
import numpy as np
import pandas as pd

from config import REGIONS, CHIP_TYPES, BASE_YEAR, \
                   DEFAULT_SIGMA, DEFAULT_EPSILON, \
                   DEFAULT_SUPPLY_ELASTICITY, DEFAULT_RD_INTENSITY
from classification import construct_region_level_series

def calibrate_armington_shares(region_trade_data) -> Dict:
    """
    利用基年贸易份额标定 CES 权重 β_{i,j,s}.
    region_trade_data 来自 construct_region_level_series().
    返回结构: beta[(origin, dest, chip_type)] = ...
    """
    beta = {}
    # TODO: 按基年份额直接赋值，保证 ∑_i β = 1
    return beta

def calibrate_demand_parameters(region_trade_data,
                                beta: Dict) -> Dict:
    """
    根据基年消费量 Q, 价格 P（可归一化为1）标定需求规模参数 A_{j,s}.
    """
    A = {}
    # TODO: 根据 Q = A * P^{-ε}，求 A = Q / P^{-ε}
    return A

def calibrate_supply_parameters(production_data,
                                initial_prices=None) -> Dict:
    """
    估计供给函数 Q_{i,s} = γ_{i,s} (P_{i,s})^{η_{i,s}} 中的 γ_{i,s}.
    生产数据可来自 IPG 指数 + SIA 的销售额拆分.
    """
    gamma = {}
    # TODO: 使用基年 Q 和假定价格 P=1 反推出 γ
    return gamma

def calibrate_rd_and_tech(initial_sales: Dict) -> Dict:
    """
    根据销售额与 SIA 的 R&D 占比，设定基期 RD_{i,s}, T_{i,s}.
    initial_sales: Sales_{i,s,BASE_YEAR}
    """
    rd = {}
    tech = {}
    for i in REGIONS:
        for s in CHIP_TYPES:
            rho = DEFAULT_RD_INTENSITY[i][s]
            sales = initial_sales.get((i, s), 1.0)
            rd[(i, s)] = rho * sales
            # 初始技术水平：以 US_H = 1 归一化，其他根据假设或文献设定
            tech[(i, s)] = 1.0  # TODO: 设定 CN, ROW 的相对水平
    return {"RD": rd, "T": tech}

def run_full_calibration(preprocessed_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    一次性完成：Armington β、需求 A、供给 γ、R&D/技术初值等标定.
    """
    region_trade_data = construct_region_level_series(
        preprocessed_data["trade"]["trade_export"]
    )
    beta = calibrate_armington_shares(region_trade_data)
    A = calibrate_demand_parameters(region_trade_data, beta)
    gamma = calibrate_supply_parameters(preprocessed_data["industry"])
    initial_sales = {}  # TODO: 用贸易+产量推销售额
    rd_tech = calibrate_rd_and_tech(initial_sales)

    params = {
        "sigma": DEFAULT_SIGMA,
        "epsilon": DEFAULT_EPSILON,
        "supply_eta": DEFAULT_SUPPLY_ELASTICITY,
        "beta": beta,
        "A": A,
        "gamma": gamma,
        "rd_intensity": DEFAULT_RD_INTENSITY,
        "tech_initial": rd_tech["T"],
        "rd_initial": rd_tech["RD"],
    }
    return params
```

---

## 6. `policy.py`：关税/补贴/出口管制情景

```python
# policy.py
from typing import Dict, Tuple
from config import REGIONS, CHIP_TYPES, VERY_LARGE_TARIFF

ScenarioName = str

def scenario_baseline(year: int) -> Dict[Tuple[str, str, str], float]:
    """
    基准情景：芯片 MFN=0，已有对华高端出口管制。
    返回关税率 τ_{importer, chip_type, exporter}.
    """
    tau = {}
    for j in REGIONS:
        for i in REGIONS:
            if i == j:
                continue
            for s in CHIP_TYPES:
                tau[(j, s, i)] = 0.0

    # 出口管制：US → CN 高端芯片近似禁运
    tau[("CN", "H", "US")] = VERY_LARGE_TARIFF
    return tau

def scenario_tariff_only(year: int) -> Dict[Tuple[str, str, str], float]:
    """
    Scenario 2: 以关税替代补贴，芯片也纳入互惠关税:
      - 对所有伙伴设 10% baseline
      - 对中国更高（如 30%）
    出口管制略有放松，可在其他模块实现（如提高配额）。
    """
    tau = {}
    for j in REGIONS:
        for i in REGIONS:
            if i == j:
                continue
            for s in CHIP_TYPES:
                base = 0.10
                extra = 0.0
                if (j == "US" and i == "CN") or (j == "CN" and i == "US"):
                    extra = 0.20  # US-CN 间 30%
                tau[(j, s, i)] = base + extra
    # 可能降低 US→CN 高端的“禁运”程度：不再用 VERY_LARGE_TARIFF
    return tau

def scenario_tariff_plus_subsidy(year: int) -> Dict:
    """
    关税+补贴共用的情景: 适度关税 + CHIPS 补贴存在.
    这里同时返回关税和补贴参数.
    """
    tau = scenario_baseline(year)
    # 对中国中低端进口征关税
    for s in ["M", "L"]:
        tau[("US", s, "CN")] = 0.15

    # 简单设：补贴只给美国 H/M 制造，数值先占位
    subsidy = {}
    for s in ["H", "M"]:
        subsidy[("US", s)] = 0.05  # 单位补贴/补贴率占位

    return {"tau": tau, "subsidy": subsidy}

def scenario_diff_by_chip_type(year: int) -> Dict:
    """
    精细情景：高端零关税，中低端对中国高关税等。
    """
    tau = {}
    for j in REGIONS:
        for i in REGIONS:
            if i == j:
                continue
            for s in CHIP_TYPES:
                if s == "H":
                    # 与盟友零关税，与中国也可设低关税以保持高端供应链开放
                    tau[(j, s, i)] = 0.0
                else:
                    base = 0.0
                    extra = 0.0
                    if j == "US" and i == "CN":
                        extra = 0.20  # 中低端对中国较高关税
                    tau[(j, s, i)] = base + extra
    return tau

SCENARIO_FUNC_MAP = {
    "baseline": scenario_baseline,
    "tariff_only": scenario_tariff_only,
    "tariff_plus_subsidy": scenario_tariff_plus_subsidy,
    "diff_by_chip": scenario_diff_by_chip_type,
}
```

---

## 7. `model_static.py`：单期部分均衡（贸易+产出）

```python
# model_static.py
from typing import Dict, Tuple, Any
import numpy as np

from config import REGIONS, CHIP_TYPES

def compute_ces_price(beta, sigma, prices_with_tariff):
    """
    计算 CES 聚合价格 P^{cons}_{j,s}.
    prices_with_tariff[(i,j,s)] = P_{i,s} * (1 + τ_{j,s}^i)
    """
    P_cons = {}
    for j in REGIONS:
        for s in CHIP_TYPES:
            sig = sigma[s]
            num = 0.0
            for i in REGIONS:
                if i == j:
                    continue
                pij = prices_with_tariff[(i, j, s)]
                b = beta[(i, j, s)]
                num += b * (pij ** (1 - sig))
            P_cons[(j, s)] = num ** (1 / (1 - sig))
    return P_cons

def demand_q(A, epsilon, P_cons):
    """Q^{cons}_{j,s} = A_{j,s} * P^{-ε}."""
    Q_cons = {}
    for j in REGIONS:
        for s in CHIP_TYPES:
            A_js = A[(j, s)]
            eps = epsilon[j][s]
            P_js = P_cons[(j, s)]
            Q_cons[(j, s)] = A_js * (P_js ** (-eps))
    return Q_cons

def allocate_imports_armington(beta, sigma, Q_cons, prices_with_tariff):
    """
    根据 CES 需求和来源价格，反推各来源进口量 Q_{i->j,s}.
    """
    Q_trade = {}
    for j in REGIONS:
        for s in CHIP_TYPES:
            sig = sigma[s]
            total_Q = Q_cons[(j, s)]
            denom = 0.0
            share = {}
            for i in REGIONS:
                if i == j:
                    continue
                pij = prices_with_tariff[(i, j, s)]
                b = beta[(i, j, s)]
                share[(i, j, s)] = b * (pij ** (1 - sig))
                denom += share[(i, j, s)]
            for i in REGIONS:
                if i == j:
                    continue
                Q_trade[(i, j, s)] = total_Q * share[(i, j, s)] / denom
    return Q_trade

def supply_q(gamma, eta, prices, subsidy=None):
    """
    Q_{i,s}^{prod} = γ_{i,s} * (P_{i,s} + Sub_{i,s})^{η_{i,s}}
    subsidy: dict[(i,s)] -> Sub_{i,s}
    """
    Q_prod = {}
    for i in REGIONS:
        for s in CHIP_TYPES:
            g = gamma[(i, s)]
            eta_is = eta[i][s]
            P_is = prices[(i, s)]
            sub = 0.0
            if subsidy and (i, s) in subsidy:
                sub = subsidy[(i, s)]
            Q_prod[(i, s)] = g * ((P_is + sub) ** eta_is)
    return Q_prod

def market_clearing_conditions(vars_vec, params, policy_t) -> np.ndarray:
    """
    非线性方程组 F(x)=0，用于求解 P_{i,s}, Q_{i,s}^{prod}, Q_{i->j,s} 等。
    为简化伪代码，这里只说明结构：
      - vars_vec: 打包的所有待求变量
      - params: A, β, σ, ε, γ, η 等
      - policy_t: 当期关税 τ 与补贴 Sub
    返回残差向量.
    """
    # TODO: 把 vars_vec 解包为 prices, trade_flows, production 等
    # 1. 根据 prices+τ 得到 prices_with_tariff
    # 2. 计算 CES 价格 P_cons, 再计算 Q_cons
    # 3. 分配进口得到 Q_trade
    # 4. 计算供给 Q_prod
    # 5. 针对每个 (i,s) 加资源约束: Q_prod - ∑_j Q_trade = 0
    # 6. 若把价格视为自由变量，还需设定 numeraire 或加一个价格归一化条件
    return np.zeros_like(vars_vec)

def solve_static_equilibrium(params: Dict[str, Any],
                             policy_t: Dict[str, Any]) -> Dict[str, Any]:
    """
    在给定某年政策 (关税+补贴+出口管制) 下，求解单期均衡。
    返回: prices, Q_prod, Q_trade, government_revenue 等.
    """
    # 1. 初始化变量向量 vars_vec0（价格=1，产量=基年值，贸易=基年值）
    # 2. 使用数值求解器（如 scipy.optimize.fsolve 或 root），求解 market_clearing_conditions
    # 3. 把解再打包回 dict 形式
    result = {
        "prices": {},         # (i,s) -> P_{i,s}
        "Q_prod": {},         # (i,s) -> Q_{i,s}^{prod}
        "Q_trade": {},        # (i,j,s) -> Q_{i->j,s}
        "gov_revenue": 0.0,   # 当期关税收入
        "consumption": {},    # (j,s) -> Q^{cons}_{j,s}
    }
    # TODO: 实现上述步骤
    return result
```

---

## 8. `model_dynamic.py`：R&D、技术演化、国家安全和福利

```python
# model_dynamic.py
from typing import Dict, Tuple
from math import log
from config import REGIONS, CHIP_TYPES, TECH_PROGRESS_COEF, \
                   SECURITY_WEIGHTS, TECH_GAP_WEIGHT

def compute_sales(prices, Q_prod) -> Dict[Tuple[str, str], float]:
    """Sales_{i,s} = P_{i,s} * Q_{i,s}^{prod}."""
    sales = {}
    for i in REGIONS:
        for s in CHIP_TYPES:
            sales[(i, s)] = prices[(i, s)] * Q_prod[(i, s)]
    return sales

def update_rd_and_tech(prev_T, sales, rd_intensity, world_sales) -> Dict:
    """
    T_{i,s,t+1} = T_{i,s,t} * (1 + φ_s * RD_{i,s,t} / Sales_{world,s,t})
    RD_{i,s,t} = ρ_{i,s} * Sales_{i,s,t}
    """
    new_T = {}
    RD = {}
    for i in REGIONS:
        for s in CHIP_TYPES:
            rho = rd_intensity[i][s]
            S_is = sales[(i, s)]
            RD[(i, s)] = rho * S_is
    # 计算各 s 的全球销售
    for s in CHIP_TYPES:
        total_world = sum(sales[(i, s)] for i in REGIONS)
        for i in REGIONS:
            phi = TECH_PROGRESS_COEF[s]
            T_old = prev_T[(i, s)]
            RD_is = RD[(i, s)]
            new_T[(i, s)] = T_old * (1 + phi * RD_is / (total_world + 1e-9))
    return {"T": new_T, "RD": RD}

def compute_supply_security(Q_trade, Q_cons) -> Dict[str, float]:
    """
    SAF_{s} = 1 - Import^{risk}_{US,s} / Cons_{US,s}.
    假设风险来源主要为中国.
    """
    SAF = {}
    for s in CHIP_TYPES:
        # US 从 CN 进口：
        risk_import = Q_trade.get(("CN", "US", s), 0.0)
        cons_US = Q_cons.get(("US", s), risk_import + 1e-9)
        SAF[s] = 1.0 - risk_import / cons_US
    return SAF

def compute_tech_gap(T) -> float:
    """Gap_H = ln(T_US,H / T_CN,H)."""
    T_US = T[("US", "H")]
    T_CN = T[("CN", "H")]
    return log((T_US + 1e-9) / (T_CN + 1e-9))

def compute_national_security_index(SAF: Dict[str, float],
                                    gap_H: float) -> float:
    """NSI = ∑_s w_s * SAF_s + μ * Gap_H."""
    nsi = 0.0
    for s in CHIP_TYPES:
        w = SECURITY_WEIGHTS[s]
        nsi += w * SAF[s]
    nsi += TECH_GAP_WEIGHT * gap_H
    return nsi

def compute_welfare(static_result, rd_cost, subsidy_cost) -> float:
    """
    简化版福利:
      W = CS + PS + TariffRevenue - Subsidy - RD_cost
    这里可先实现 TariffRevenue - Subsidy - RD_cost，
    CS/PS 可后续补充或用简化代理指标.
    """
    gov_rev = static_result["gov_revenue"]
    # TODO: 估算或计算 CS 和 PS（可根据需求/成本函数解析或数值积分）
    CS = 0.0
    PS = 0.0
    W = CS + PS + gov_rev - subsidy_cost - rd_cost
    return W
```

---

## 9. `simulate.py`：多期仿真主循环

```python
# simulate.py
from typing import Dict, Any
from config import SIM_YEARS, DISCOUNT, SECURITY_VS_WELFARE
from data_loader import preprocess_all
from calibration import run_full_calibration
from policy import SCENARIO_FUNC_MAP
from model_static import solve_static_equilibrium
from model_dynamic import (
    compute_sales, update_rd_and_tech,
    compute_supply_security, compute_tech_gap,
    compute_national_security_index, compute_welfare
)

def run_scenario(scenario_name: str) -> Dict[str, Any]:
    """
    在给定情景下，对 SIM_YEARS 做动态仿真。
    返回字典包含：年度路径、折现后的目标值 Obj.
    """
    # 1. 数据预处理 & 参数标定（现实中可放在外面、只做一次）
    data = preprocess_all()
    params = run_full_calibration(data)

    # 2. 初始化状态: 技术 T, RD, etc.
    state_T = params["tech_initial"]
    rd_intensity = params["rd_intensity"]

    # 记录路径
    history = {
        "year": [],
        "NSI": [],
        "Welfare": [],
        "Obj_t": [],
        "T": [],
        "security": [],
        "others": [],
    }

    scenario_func = SCENARIO_FUNC_MAP[scenario_name]

    discounted_obj = 0.0

    for t_idx, year in enumerate(SIM_YEARS):
        # 3. 生成该年的政策参数
        policy_result = scenario_func(year)
        if isinstance(policy_result, dict) and "tau" in policy_result:
            tau_t = policy_result["tau"]
            subsidy_t = policy_result.get("subsidy", {})
        else:
            tau_t = policy_result
            subsidy_t = {}

        policy_t = {"tau": tau_t, "subsidy": subsidy_t}

        # 4. 单期静态均衡
        static_result = solve_static_equilibrium(params, policy_t)

        prices = static_result["prices"]
        Q_prod = static_result["Q_prod"]
        Q_trade = static_result["Q_trade"]
        Q_cons = static_result["consumption"]

        # 5. 动态模块：销售、R&D、技术更新
        sales = compute_sales(prices, Q_prod)
        rd_tech = update_rd_and_tech(state_T, sales, rd_intensity, world_sales=None)
        state_T = rd_tech["T"]
        RD_t = rd_tech["RD"]

        # 6. 计算国家安全指标 NSI_t
        SAF = compute_supply_security(Q_trade, Q_cons)
        gap_H = compute_tech_gap(state_T)
        NSI_t = compute_national_security_index(SAF, gap_H)

        # 7. 计算福利指标 W_t
        rd_cost = sum(RD_t.values())
        subsidy_cost = sum(
            subsidy_t.get((i, s), 0.0) * Q_prod[(i, s)]
            for (i, s) in Q_prod.keys()
        )
        W_t = compute_welfare(static_result, rd_cost, subsidy_cost)

        # 8. 合成目标 Obj_t = W_t + λ * NSI_t
        Obj_t = W_t + SECURITY_VS_WELFARE * NSI_t
        discounted_obj += (DISCOUNT ** t_idx) * Obj_t

        # 9. 保存路径
        history["year"].append(year)
        history["NSI"].append(NSI_t)
        history["Welfare"].append(W_t)
        history["Obj_t"].append(Obj_t)
        history["T"].append(state_T.copy())
        history["security"].append(SAF)

    history["discounted_obj"] = discounted_obj
    return history

def run_all_scenarios():
    """遍历所有情景，比较结果."""
    results = {}
    for scen in SCENARIO_FUNC_MAP.keys():
        print(f"Running scenario: {scen}")
        results[scen] = run_scenario(scen)
    return results

if __name__ == "__main__":
    results = run_all_scenarios()
    # TODO: 把 results 传给 analysis_plots 画图 & 生成表格
```

---

## 10. `analysis_plots.py`：结果可视化（简要伪代码）

```python
# analysis_plots.py
import matplotlib.pyplot as plt

def plot_time_series(results_all):
    """
    传入 run_all_scenarios 的结果，画：
      - NSI_t 随时间
      - Welfare_t 随时间
      - 美国对中国中低端芯片进口占比
      - 技术差距 Gap_H_t
    """
    # TODO: 实际实现：循环 scenarios 和年份，画多条线
    pass
```

---

这样，你就有了一套**完整但可扩展的 Python 伪代码框架**：

* 已把**高/中/低端划分、Armington 贸易模型、R&D–技术演化、国家安全指数、福利目标函数**都在代码层面“落了地”；
* 每个模块都预留了 `TODO`，方便你根据实际数据一步步补全。

你可以的做法：

1. 先实现 `data_loader.py` 和 `classification.py`（确保高/中/低端拆分出来）；
2. 再写 `calibration.run_full_calibration()` 的真实标定；
3. 最后实现 `model_static.solve_static_equilibrium()` 中的求解（用 `scipy.optimize`）。

